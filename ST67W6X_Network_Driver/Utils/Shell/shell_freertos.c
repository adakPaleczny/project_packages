/**
  ******************************************************************************
  * @file    shell_freertos.c
  * @author  GPM Application Team
  * @brief   This file provides the implementation of the Shell FreeRTOS Task management
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2024 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */

/* Includes ------------------------------------------------------------------*/
#include <inttypes.h>
#include <stdio.h>
#include <stdarg.h>

#include "shell_internal.h"
#include "shell.h"

#include "FreeRTOS.h"
#include <semphr.h>
#include "task.h"
#include "queue.h"

/* Private defines -----------------------------------------------------------*/
#ifndef SHELL_MESSAGE_ID
/** Log id. must be unique per queue producer */
#define SHELL_MESSAGE_ID 2
#endif /* SHELL_MESSAGE_ID */

/* Private typedef -----------------------------------------------------------*/
/** @addtogroup ST67W6X_Utilities_Shell_Types
  * @{
  */

/**
  * @brief  Create a typename for struct _ShellFreeRTOS
  */
typedef struct _shell_freertos shell_free_rtos_t;

/**
  * @brief  Shell message structure
  */
typedef struct
{
  uint32_t message_id;    /*!< Log id. must be unique per queue producer */
  uint32_t message_len;   /*!< Length of the message */
  char *message;          /*!< Pointer to the message */
} ShellMessage_t;

/**
  * @brief  Internal state of the low level support implementation for the shell.
  */
struct _shell_freertos
{
  /** handle of the RX shell task. */
  TaskHandle_t task;

  /** Synchronization primitive used to synchronize the shell rx task with the uart rx ISR. */
  SemaphoreHandle_t rx_sem;

  /** Rx buffer used by the ::Ring_Buffer_t object to buffer the user input data. */
  uint8_t rx_buffer[SHELL_FREERTOS_RX_BUFF_SIZE];
  /** Rx buffer index. */
  uint32_t rx_buffer_idx;
  /** Synchronization primitive used to output the data generated by the shell. */
  QueueHandle_t OutputQueue;

  /** This implementation read the user input from the uart, in interrupt mode, 1 byte at time.
    * That byte is stored here. */
  volatile uint8_t uart_rx_byte;

  /** Hw used to read the user input. */
  UART_HandleTypeDef *p_rx_uart;
};

/** @} */

/* Private function prototypes -----------------------------------------------*/
/** @addtogroup ST67W6X_Utilities_Shell_Functions
  * @{
  */
/**
  * @brief  Printf implementation used by the shell.
  * @param  p_format [IN] specifies the format string.
  */
void shell_freertos_printf(const char *const p_format, ...);

/**
  * @brief  Task that read the user input from the uart and call the upper layer to process it.
  * @param  p_params [IN] specifies the shell instance.
  */
void shell_freertos_rx_task(void *p_params);

/**
  * @brief  Callback called by the uart ISR when a new byte is received.
  * @param  uart_rxbyte [IN] specifies the byte received.
  */
static void shell_freertos_on_new_data(uint8_t uart_rxbyte);

/**
  * @brief  Release the semaphore used to synchronize the shell rx task with the uart rx ISR.
  */
static inline void shell_freertos_release_sem(void);

/**
  * @brief  Callback called by the uart ISR when a new byte is received.
  * @param  huart [IN] specifies the uart handle.
  */
void shell_freertos_uart_rx_cplt_callback(UART_HandleTypeDef *huart);

/**
  * @brief  Get the only instance of the shell.
  * @return the only instance of the shell.
  */
static shell_free_rtos_t *shell_freertos_get_instance(void);

/**
  * @brief  Get the only instance of the shell.
  * @return the only instance of the shell.
  */
shell_free_rtos_t *shell_freertos_get_instance(void);

/* Functions Definition ------------------------------------------------------*/
shell_free_rtos_t *shell_freertos_get_instance(void)
{
  static shell_free_rtos_t sTheObj =
  {
    .task = NULL,
    .rx_sem = NULL,
    .OutputQueue = NULL,
    .p_rx_uart = NULL
  };

  return &sTheObj;
}

void shell_freertos_init(UART_HandleTypeDef *p_rx_uart, void *xLogQueue)
{
#if (SHELL_ENABLE == 1)
  configASSERT(p_rx_uart != NULL);

  shell_free_rtos_t *p_shell = shell_freertos_get_instance();
  HAL_StatusTypeDef status;

  p_shell->p_rx_uart = p_rx_uart;
  p_shell->OutputQueue = xLogQueue;

  status = HAL_UART_RegisterCallback(p_shell->p_rx_uart, HAL_UART_RX_COMPLETE_CB_ID,
                                     shell_freertos_uart_rx_cplt_callback);
  configASSERT(status == HAL_OK);

  p_shell->rx_sem = xSemaphoreCreateBinary();
  configASSERT(p_shell->rx_sem != NULL);

  /* Initialize the upper layer */
  if (xLogQueue == NULL)
  {
    /* if no queue, then printf */
    shell_init((void (*)(char *fmt, ...))printf);
  }
  else
  {
    shell_init((void (*)(char *fmt, ...)) shell_freertos_printf);
  }

  /* Create the task that handle the user input */
  if (pdPASS != xTaskCreate(shell_freertos_rx_task, (char *) "shell_task",
                            SHELL_FREERTOS_RX_THREAD_STACK_SIZE >> 2,
                            p_shell, SHELL_FREERTOS_RX_THREAD_PRIO, &p_shell->task))
  {
    SHELL_E("failed to create shell task\n");
    return;
  }

  /* Start the process by reading the user input */
  status = HAL_UART_Receive_IT(p_shell->p_rx_uart, (uint8_t *)&p_shell->uart_rx_byte, 1);
  if (status != HAL_OK)
  {
    SHELL_E("failed to setup uart reception, %" PRIi32 "\n", status);
  }
#endif /* SHELL_ENABLE */
}

void shell_freertos_deinit(void)
{
#if (SHELL_ENABLE == 1)
  shell_free_rtos_t *p_shell = shell_freertos_get_instance();

  HAL_UART_UnRegisterCallback(p_shell->p_rx_uart, HAL_UART_RX_COMPLETE_CB_ID);

  if (p_shell->task != NULL)
  {
    vTaskDelete(p_shell->task);
    p_shell->task = NULL;
  }

  if (p_shell->rx_sem != NULL)
  {
    vSemaphoreDelete(p_shell->rx_sem);
    p_shell->rx_sem = NULL;
  }

  if (p_shell->OutputQueue != NULL)
  {
    p_shell->OutputQueue = NULL;
  }
#endif /* SHELL_ENABLE */
}

/* Private Functions Definition ----------------------------------------------*/
void shell_freertos_rx_task(void *p_params)
{
  shell_free_rtos_t *p_shell = (shell_free_rtos_t *)p_params;

  while (1)
  {
    if (xSemaphoreTake(p_shell->rx_sem, portMAX_DELAY) == pdTRUE)
    {
      for (uint32_t i = 0; i < p_shell->rx_buffer_idx; i++)
      {
        shell_handler(p_shell->rx_buffer[i]);
      }
      p_shell->rx_buffer_idx = 0;
    }
  }
}

static void shell_freertos_on_new_data(uint8_t uart_rxbyte)
{
  shell_free_rtos_t *p_shell = shell_freertos_get_instance();

  if (p_shell->rx_buffer_idx < SHELL_FREERTOS_RX_BUFF_SIZE)
  {
    p_shell->rx_buffer[p_shell->rx_buffer_idx++] = uart_rxbyte;
  }
  else
  {
    printf("Error: SHELL_FREERTOS_RX_BUFF_SIZE reached\n");
  }
  shell_freertos_release_sem();
}

void shell_freertos_printf(const char *const p_format, ...)
{
  /* Allocate memory for the log structure */
  int32_t alloc_len;
  va_list args;
  char dummy_str[2];/* dummy string for format length calculation */
  shell_free_rtos_t *p_shell = shell_freertos_get_instance();
  ShellMessage_t *newShell = (ShellMessage_t *)pvPortMalloc(sizeof(ShellMessage_t));

  if (newShell == NULL)
  {
    printf("Error: Shell malloc failed\n");
    return;
  }

  va_start(args, p_format);

  alloc_len = vsnprintf(dummy_str, sizeof(dummy_str) - 1, p_format, args) + 1; /* +1 for'\0' */

  if (alloc_len > SHELL_FREERTOS_MAX_PRINT_STRING_LENGTH)
  {
    alloc_len = SHELL_FREERTOS_MAX_PRINT_STRING_LENGTH;
  }

  /* Allocate memory for the log message */
  newShell->message = (char *)pvPortMalloc(alloc_len);
  if (newShell->message == NULL)
  {
    vPortFree(newShell);
    printf("Error: Shell message malloc failed\n");
    va_end(args);
    return;
  }

  /* Append the actual log message */
  (void)vsnprintf(newShell->message, alloc_len, p_format, args);

  va_end(args);

  configASSERT(alloc_len != strlen(newShell->message));
  newShell->message_len = alloc_len;

  newShell->message_id = SHELL_MESSAGE_ID;

  /* Send the log to the queue */
  if (xQueueSendToBack(p_shell->OutputQueue, &newShell, 0) != pdPASS)
  {
    vPortFree(newShell->message);
    vPortFree(newShell);
    printf("Error: Shell queue full, message dropped\n");
  }
}

static inline void shell_freertos_release_sem(void)
{
  shell_free_rtos_t *p_shell = shell_freertos_get_instance();
  BaseType_t xHigherPriorityTaskWoken = pdFALSE;

  if (xPortIsInsideInterrupt())
  {
    if (xSemaphoreGiveFromISR(p_shell->rx_sem, &xHigherPriorityTaskWoken) == pdPASS)
    {
      portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
    }
  }
  else
  {
    (void)xSemaphoreGive(p_shell->rx_sem);
  }
}

void shell_freertos_uart_rx_cplt_callback(UART_HandleTypeDef *huart)
{
  HAL_StatusTypeDef status;
  shell_free_rtos_t *p_shell = shell_freertos_get_instance();

  if (huart->Instance == p_shell->p_rx_uart->Instance)
  {
    shell_freertos_on_new_data(p_shell->uart_rx_byte);
    /* Set up next uart reception */
    status = HAL_UART_Receive_IT(p_shell->p_rx_uart, (uint8_t *)&p_shell->uart_rx_byte, 1);
    configASSERT(status == HAL_OK);
  }
}

/** @} */
